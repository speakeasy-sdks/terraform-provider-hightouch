// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"bytes"
	"encoding/json"
	"errors"
)

type SyncScheduleScheduleType string

const (
	SyncScheduleScheduleTypeIntervalSchedule   SyncScheduleScheduleType = "IntervalSchedule"
	SyncScheduleScheduleTypeCronSchedule       SyncScheduleScheduleType = "CronSchedule"
	SyncScheduleScheduleTypeVisualCronSchedule SyncScheduleScheduleType = "VisualCronSchedule"
	SyncScheduleScheduleTypeDBTSchedule        SyncScheduleScheduleType = "DBTSchedule"
)

type SyncScheduleSchedule struct {
	IntervalSchedule   *IntervalSchedule
	CronSchedule       *CronSchedule
	VisualCronSchedule *VisualCronSchedule
	DBTSchedule        *DBTSchedule

	Type SyncScheduleScheduleType
}

func CreateSyncScheduleScheduleIntervalSchedule(intervalSchedule IntervalSchedule) SyncScheduleSchedule {
	typ := SyncScheduleScheduleTypeIntervalSchedule

	return SyncScheduleSchedule{
		IntervalSchedule: &intervalSchedule,
		Type:             typ,
	}
}

func CreateSyncScheduleScheduleCronSchedule(cronSchedule CronSchedule) SyncScheduleSchedule {
	typ := SyncScheduleScheduleTypeCronSchedule

	return SyncScheduleSchedule{
		CronSchedule: &cronSchedule,
		Type:         typ,
	}
}

func CreateSyncScheduleScheduleVisualCronSchedule(visualCronSchedule VisualCronSchedule) SyncScheduleSchedule {
	typ := SyncScheduleScheduleTypeVisualCronSchedule

	return SyncScheduleSchedule{
		VisualCronSchedule: &visualCronSchedule,
		Type:               typ,
	}
}

func CreateSyncScheduleScheduleDBTSchedule(dbtSchedule DBTSchedule) SyncScheduleSchedule {
	typ := SyncScheduleScheduleTypeDBTSchedule

	return SyncScheduleSchedule{
		DBTSchedule: &dbtSchedule,
		Type:        typ,
	}
}

func (u *SyncScheduleSchedule) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	intervalSchedule := new(IntervalSchedule)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&intervalSchedule); err == nil {
		u.IntervalSchedule = intervalSchedule
		u.Type = SyncScheduleScheduleTypeIntervalSchedule
		return nil
	}

	cronSchedule := new(CronSchedule)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&cronSchedule); err == nil {
		u.CronSchedule = cronSchedule
		u.Type = SyncScheduleScheduleTypeCronSchedule
		return nil
	}

	visualCronSchedule := new(VisualCronSchedule)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&visualCronSchedule); err == nil {
		u.VisualCronSchedule = visualCronSchedule
		u.Type = SyncScheduleScheduleTypeVisualCronSchedule
		return nil
	}

	dbtSchedule := new(DBTSchedule)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&dbtSchedule); err == nil {
		u.DBTSchedule = dbtSchedule
		u.Type = SyncScheduleScheduleTypeDBTSchedule
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SyncScheduleSchedule) MarshalJSON() ([]byte, error) {
	if u.IntervalSchedule != nil {
		return json.Marshal(u.IntervalSchedule)
	}

	if u.CronSchedule != nil {
		return json.Marshal(u.CronSchedule)
	}

	if u.VisualCronSchedule != nil {
		return json.Marshal(u.VisualCronSchedule)
	}

	if u.DBTSchedule != nil {
		return json.Marshal(u.DBTSchedule)
	}

	return nil, nil
}

// SyncSchedule - The scheduling configuration. It can be triggerd based on several ways:
//
// Interval: the sync will be trigged based on certain interval(minutes/hours/days/weeks)
//
// Cron: the sync will be trigged based on cron expression https://en.wikipedia.org/wiki/Cron.
//
// Visual: the sync will be trigged based a visual cron configuration on UI
//
// DBT-cloud: the sync will be trigged based on a dbt cloud job
type SyncSchedule struct {
	Schedule SyncScheduleSchedule `json:"schedule"`
	Type     string               `json:"type"`
}

type ValidateErrorJSON struct {
	Details map[string]interface{}   `json:"details"`
	Message ValidateErrorJSONMessage `json:"message"`
}
