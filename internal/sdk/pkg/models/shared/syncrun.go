// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"time"
)

// SyncRunFailedRows - The number of rows that we attempted to sync, but were rejected by the
// destination.
//
// This does not include rows that weren't attempted due to the sync being
// cancelled.
type SyncRunFailedRows struct {
	// The number of failed adds.
	AddedCount float64 `json:"addedCount"`
	// The number of failed changes.
	ChangedCount float64 `json:"changedCount"`
	// The number of failed removes.
	RemovedCount float64 `json:"removedCount"`
}

// SyncRunPlannedRows - The number of planned rows that this sync run was supposed to execute.
//
// Note that the counts for `successfulRows` and `failedRows` may not add up
// to `plannedRows` if the sync was cancelled.
type SyncRunPlannedRows struct {
	// The number of added rows.
	AddedCount float64 `json:"addedCount"`
	// The number of changed rows.
	ChangedCount float64 `json:"changedCount"`
	// The number of removed rows.
	RemovedCount float64 `json:"removedCount"`
}

// SyncRunSuccessfulRows - The number of rows that were successfully processed by the destination.
type SyncRunSuccessfulRows struct {
	// The number of successful adds.
	AddedCount float64 `json:"addedCount"`
	// The number of successful changes.
	ChangedCount float64 `json:"changedCount"`
	// The number of successful removes.
	RemovedCount float64 `json:"removedCount"`
}

type SyncRun struct {
	// The completion ratio of sync run, showing the progress of a sync run
	CompletionRatio float64 `json:"completionRatio"`
	// The timestamp when sync run was created. In most cases this will be
	// equivalent to `startedAt`, but it may be earlier if the sync was triggered
	// while a run was already in progress, and the new run didn't start for
	// a while.
	CreatedAt time.Time `json:"createdAt"`
	// Error message if the sync run didn't finish successfully
	Error *string `json:"error,omitempty"`
	// The number of rows that we attempted to sync, but were rejected by the
	// destination.
	//
	// This does not include rows that weren't attempted due to the sync being
	// cancelled.
	FailedRows SyncRunFailedRows `json:"failedRows"`
	// The timestamp when the sync run finished
	FinishedAt time.Time `json:"finishedAt"`
	// The sync run's id
	ID string `json:"id"`
	// The number of planned rows that this sync run was supposed to execute.
	//
	// Note that the counts for `successfulRows` and `failedRows` may not add up
	// to `plannedRows` if the sync was cancelled.
	PlannedRows SyncRunPlannedRows `json:"plannedRows"`
	// The number of rows in the query.
	QuerySize float64 `json:"querySize"`
	// The timestamp when the sync run started
	StartedAt time.Time `json:"startedAt"`
	// The status of sync runs
	Status SyncRunStatus `json:"status"`
	// The number of rows that were successfully processed by the destination.
	SuccessfulRows SyncRunSuccessfulRows `json:"successfulRows"`

	AdditionalProperties interface{} `json:"-"`
}
type _SyncRun SyncRun

func (c *SyncRun) UnmarshalJSON(bs []byte) error {
	data := _SyncRun{}

	if err := json.Unmarshal(bs, &data); err != nil {
		return err
	}
	*c = SyncRun(data)

	additionalFields := make(map[string]interface{})

	if err := json.Unmarshal(bs, &additionalFields); err != nil {
		return err
	}
	delete(additionalFields, "completionRatio")
	delete(additionalFields, "createdAt")
	delete(additionalFields, "error")
	delete(additionalFields, "failedRows")
	delete(additionalFields, "finishedAt")
	delete(additionalFields, "id")
	delete(additionalFields, "plannedRows")
	delete(additionalFields, "querySize")
	delete(additionalFields, "startedAt")
	delete(additionalFields, "status")
	delete(additionalFields, "successfulRows")

	c.AdditionalProperties = additionalFields

	return nil
}

func (c SyncRun) MarshalJSON() ([]byte, error) {
	out := map[string]interface{}{}
	bs, err := json.Marshal(_SyncRun(c))
	if err != nil {
		return nil, err
	}

	if err := json.Unmarshal([]byte(bs), &out); err != nil {
		return nil, err
	}

	bs, err = json.Marshal(c.AdditionalProperties)
	if err != nil {
		return nil, err
	}

	if err := json.Unmarshal([]byte(bs), &out); err != nil {
		return nil, err
	}

	return json.Marshal(out)
}
